做过的项目，C语言笔试，Linux系统编程、驱动编程、操作系统。

### 1、Linux内核体系结构

一个完整可用的操作系统主要由四个部分组成：硬件、操作系统内核、操作系统服务和用户应用程序。操作系统内核主要用于对硬件资源的抽象和访问调度。

![操作系统组成](E:\zhf\笔记\Gitee\note\嵌入式\pic\操作系统组成.png)

Linux内核的主要用途是为了与计算机硬件进行交互，实现对硬件部件的编程控制和接口操作，调度对硬件资源的访问，并为计算机上的用户程序提供一个高级的执行环境和对硬件的虚拟接口。

#### 1.1 Linux内核模式

目前Linux内核模式主要可分为**整体的单内核模式**和**层次式的微内核模式**。

在单核模式的系统中，操作系统所提供服务的流程为：应用程序使用指定的参数值执行系统调用指令，使CPU从用户态切换到核心态，然后操作系统根据具体的参数值调用特定的系统调用服务程序，这些服务程序根据需求在调用底层的一些支持函数已完成特定的功能。在完成了应用程序所要求的服务后，操作系统又使CPU从核心态切换回用户态。

Linux内核主要由5个模块构成：**进程调用模块**、**内存管理模块**、**文件系统模块**、进**程间通信模块**和**网络接口模块**。

![内核各模块关系](E:\zhf\笔记\Gitee\note\嵌入式\pic\内核各模块关系.png)

#### 1.2 Linux内核对内存的管理和使用

##### 物理内存

为了能够有效的使用机器中的物理内存，在系统初始化阶段内存被划分为几个功能区域：![物理内存功能分布](E:\zhf\笔记\Gitee\note\嵌入式\pic\物理内存功能分布.png)

在Intel 80386及以后的CPU中提供了两种内存管理（地址变换）系统：**内存分段系统**和**内存分页系统**。其中分页管理系统是可选择的，由系统程序员通过编程来确定是否采用。Linux系统**同时采用了内存分段和分页**。

##### 内存地址空间

在进行地址映射操作时，有三种地址：程序（进程）的虚拟和逻辑地址；CPU的线性地址；实际物理内存地址。

**虚拟地址**：由程序产生的由**段选择符**和**段内偏移地址**两个部分组成的地址。这两部分组成的地址并没有直接用来访问物理内存，而是需要通过分段地址变换机制处理或者映射后才对应到物理内存地址上。选择的索引部分由13个比特位表示，加上GDT和LDT的一个比特位，因此CPU可以索引16384个选择符。每个段的长度取最大值，则最大虚拟地址空间范围是16384*4G=64T；

**逻辑地址**：是指由程序产生的与段相关的偏移地址部分。在Intel保护模式下即是指程序执行代码段限长内的偏移地址。

**线性地址**：是虚拟地址到物理地址变换之间的中间层，是处理器可寻址的内存空间中的地址。

**物理地址**：指出现在CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果地址。如果启用了分页机制，那么线性地址会使用页目录和页表中的项变换成物理地址，如果未启用分页机制，那么线性地址直接成为物理地址。

##### 内存分段机制

CPU地址映射的主要目的是为了解决虚拟内存空间到物理内存空间的映射问题。

虚拟存储管理的实现：

当一个程序需要使用一块不存在的内存时（在内存页表项中已经标出相应内存页面不在内存中），就会触发CPU产生页出错异常中断，并将引起中断的线性地址放到CR2控制寄存器中。因此处理该中断的过程就可以知道发生页异常的确切地址，从而可以把进程要求的页面从二级存储空间（比如硬盘上）加载到物理内存中。如果此时物理内存已经被全部占用，那么可以借助二级存储空间的一部分作为交换缓冲区把内存中暂时不使用的页面交换到二级缓冲区中，然后把要求的页面调入内存中。也即**内存管理的缺页加载机制**。

内存寻址的两种方式：实模式和保护模式

在保护模式下，存在保护描述符项的描述符，有三种类型，每种有不同的目的

- 全局描述符表GDT：该表可被所有程序用于引用访问一个内存段。
- 中断描述符表IDT：保存有定义中断或者异常处理过程的段描述符。
- 局部描述符表LDT：该表用于多任务系统中，通常每个任务使用一个LDT表。

为了让CPU能定位上述三个表项，需要为CPU分别设置GDTR、IDTR和LDTR三个特殊寄存器。这些寄存器中将存储对应表的32位线性基地址和表的限长字节值。表限长值是表的长度值-1.

##### 内存分页管理

如果采取了分页机制，则此时线性地址只是一个中间结果，还需要使用分页机制进行变换，再最终映射到实际的物理内存地址上。分页机制允许我们进行重新定向每次内存应用，以适应我们的特殊要求。

内存分页管理机制的基本原理是将CPU整个线性内存区域划分为4096字节为1页的内存页面。程序申请使用内存时，系统就以内存页为单位进行分配。**分页机制是在分段机制之上实现的** ，为了在保护模式下使用分页机制，需要把控制寄存器的最高比特位（位31）置位。

在使用这种内存分页管理方法时，每个执行中的进程（任务）可以使用比实际内存容量大得多的连续地址空间。为了在使用分页机制的条件下把线性地址映射到容量相对很小的物理内存地址空间上，80386使用了**页目录表**和**页表** ，两者格式基本上相同，都占用4个字节，并且每个页目录表或页表项只能包含1024个页表项。因此一个页目录或一个页表分别工占用一页内存。页表有一个已写位，页目录项没有。

线性地址到物理地址变换：

![线性地址到物理地址](/pic/线性地址到物理地址.png)

在Intel80386系统，其CPU可以提供多达4G的线性地址空间。一个任务的虚拟地址需要首先通过其局部描述符变换为CPU整个线性地址空间中的地址，然后再使用页目录表PDT（一级页表）和页表PT（二级页表）映射到实际物理地址页上。为了使用实际物理内存，每个进程的线性地址通过二级内存页表动态地映射到主内存区域的不同物理内存页上。

##### CPU多任务保护和保护方式

CPU共分为4个保护等级，0级最高，3级最低。Linux内核代码本身会由系统中的所有任务共享。

当一个任务（进程）执行系统调用而陷入内核代码中执行时，就称该进程处于内核态。此时处理器处于特权级最高的内核代码中执行，当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，称其处于用户态。此时处理器在特权级最低的用户代码中运行。

![多任务系统](/pic/多任务系统.png)

##### 虚拟地址、线性地址和物理地址之间的关系

**内核代码和数据的地址**

对于Linux0.11内核代码和数据来说，在head.s程序的初始化操作中已经将内核代码段和数据段都设置长度为16MB的段。在线性地址空间中这两个段的范围重叠，都是从线性地址0开始到地址0XFFFFFF共16MB地址范围，在该范围中含有内核所有的代码、内核段表、页目录表和内核的二级页表、内核局部数据以及内核临时堆栈。

默认情况下Linux0.11内核最多可以管理16MB的物理内存，共有4096个物理页面（页帧），每个页面4KB。

1. 内核代码段和数据段区域在线性地址空间和物理地址空间中是一样的。
2. GDT和IDT在内核数据段中，因此他们的线性地址也同样等于他们的物理地址。
3. 除了任务0以外，所有其他任务所需要的物理内存页面与线性地址中的不同或者部分不同，因此内核需要动态地在主内存区中为他们做映射操作，动态地建立页目录项和页表项。

任务0是系统中人工启动的第一个任务。它的代码段和数据段长度被设置为640KB。该任务是代码和数据直接包含在内核代码和数据中，从线性地址0开始到640KB的内容。

##### 用户申请内存的动态分配

当用户应用程序使用c语言库malloc（）申请内存时，这些动态申请的内存容量或大小由高层的C语言库函数malloc()来管理，内核本身并不会插手。当malloc（）函数为程序分配内存时，他会通过系统调用brk()把程序要求新增的空间长度通知内核，内核代码从而可以根据malloc（）所提供的信息来更新brk()的值。但是此时并不为新申请的空间映射物理内存页面。只有当程序寻址到某个不存在对应物理页面的地址时，内核才会进行相关物理内存页面的映射操作。

当用户使用free()动态释放已申请的内存块时，C库中的内存管理函数就会把所释放的内存块标记为空闲，以备程序再次申请内存时使用。在这个过程中内核为该进程所分配的物理页面并不会被释放掉。只有当进程最终结束时内核才会全面收回已分配和映射到该进程地址空间范围的所有物理内存页面。

#### 1.3 Linux系统的中断机制

当设备向处理器提出服务请求时，处理器会在执行完当前的一条指令后立即应答设备的请求，并转而执行该设备的相关服务程序。当服务程序执行完成后，处理器会接着去做刚才被中断的程序，这种处理方式叫做中断方法。

#### 1.4 Linux的系统调用

##### 系统调用接口

系统调用时Linux内核与上层应用程序进行交互通信的唯一接口。用户程序通过直接或者间接调用中断int 0X80，并在eax寄存器中指定系统调用功能号，即可使用内核资源包括系统硬件资源。

每个系统调用都具有唯一的一个系统调用功能号。

##### 系统调用的处理过程

当应用程序经过库函数向内核发出一个中断调用int 0X80时，就开始执行一个系统调用。其中寄存器eax中存放着系统调用号，而携带的参数可依次存放在寄存器ebx、ecx、edx中。Linux0.11内核用户程序能够向内核最多直接传递三个参数，当然也可以不带参数。

##### Linux系统调用的参数传递方式

Linux系统使用了通用寄存器传递方法向系统中断调用过程传递参数。优点：当进入系统中断服务程序而保存寄存器值时，这些传递参数的寄存器也能被自动地放在内核态堆栈上，因此用不着再专门对传递参数的寄存器进行特殊处理。

#### 1.5 Linux进程控制

进程是一个执行中的程序实例。利用**分时技术**，在Linux操作系统上同时可以运行多个进程。实际上对于单个CPU机器来说某一时刻只能运行一个进程，但是由于每个进程运行的时间片很短，所以表面看来好像所有进程在同时运行着。内核通过调度程序分时调度各个进程运行。

### 2、引导启动程序

Linux操作系统启动部分的主要执行流程：当PC上电后，80X86结构的CPU将自动进入实模式，并从地址0XFFFF0（通常为ROM-BIOS中的地址）开始自动执行程序代码。PC机的BIOS将执行某些系统的检测，并在物理地址0处开始初始化中断向量。此后，它将可启动设备的第一个扇区（磁盘引导扇区，512字节）读入内存绝对地址0X7C00处，并跳转到这个地方。![Linux上电启动](/pic/Linux上电启动.png)

启动部分识别主机的某些特性以及VGA卡的类型。然后将整个系统从0X10000移至0X0000处，进入保护模式并跳转至系统的余下部分。

bootsect的代码不将系统模块直接加载到物理地址0X0000开始处，而要在setup程序中再进行移动的原因：因为随后执行的setup代码开始部分还需要利用ROM BIOS的中断调用来获取机器的一些参数。当BIOS初始化时会在物理内存开始处放置一个大小为0X400字节（1KB）的中断向量表，因此需要在使用完BIOS的中断调用后才能将这个区域覆盖掉。

##### 从硬盘启动系统

若要从磁盘设备启动系统，那么通常需要用到其他多操作系统引导程序来引导系统加载。此时bootsect.s所完成的任务会由这些程序来完成，该程序就不会被执行了。

setup.s是一个操作系统加载程序，它的主要作用是利用ROM BIOS中断读取机器系统数据，并将这些数据保存到0X90000开始的位置（覆盖掉了bootsect程序所在的地方）。

#### 3 初始化程序（init）

main.c程序：首先会利用setup.s程序取得的系统参数设置系统的根文件设备号以及一些内存全局变量。这些内存变量指明了主内存的开始地址、系统所拥有的内存容量和作为高速缓存区内存的末端地址。

高速缓存区是用于磁盘等块设备临时存放数据的地方，以1K(1024)字节为一个数据块单位。主内存区域的内存由内存管理模块mm通过分页机制进行管理分配，以4K字节为一个内存页单位。

然后内核进行所有方面的硬件初始化工作。所有初始化工作完成后程序就设置中断允许标志以开启中断，并切换到任务0去运行。

![内核初始化](/pic/内核初始化.png)

getty程序：主要任务是设置终端类型、属性、速度和线路规程。它打开并初始化一个tty端口，显示提示信息，并等待用户键入用户名密码，并执行login程序。

#### 4 内核代码

该目录下的代码文件从功能上可以分为三类，一类是硬件（异常）中断处理程序文件，一类是系统调用服务处理程序文件，另一类是进程调度等通用功能文件。

![内核目录各文件函数关系](/pic/内核目录各文件函数关系.png)

**中断处理程序**

- asm.s
  - 用于实现大部分硬件异常所引起的中断的汇编语言处理过程。
  - 主要涉及对Intel保留中断int0-int16的处理。
- traps.c
  - 实现了asm.s的中断处理过程中调用的c函数。

**系统调用处理相关程序**

Linux中应用程序调用内核的功能是通过中断调用int0x80进行的，寄存器eax中放调用号，如果需要参数，则ebx、ecx、edx用于存放调用参数。该中断调用被成为系统调用。

- system_call.s程序的作用类似于硬件中断处理中asm.s程序的作用，另外还对时钟中断和硬盘、软盘中断进行处理。
- fork.c和signal.c中的一个函数则类似于traps.c程序的作用，他们为系统调用提供c处理函数。
  - fork.c提供find_empty_process()和copy_process()两个函数.
  - signal.c还提供一个处理有关进程信号的函数do_signal().

#### 5 块设备驱动程序（block driver）

操作系统的所有设备可以粗略的分为**块设备**和**字符型设备**。

块设备：一种可以以固定大小的数据块为单位进行寻址和访问的设备，如磁盘设备和软盘设备。

字符型设备：是一种以字节流作为操作对象的设备，不能进行寻址操作，如打印机设备、网络接口设备和终端设备。

**总体功能：** 对硬盘和软盘块设备上数据的读写操作是通过中断处理程序进行的。内核每次读写的数据量以一个逻辑块（1024字节）为单位，而块设备控制器则是以扇区（512字节）为单位。在处理过程中，使用读写请求项等带队列来顺序缓冲一次读写多个逻辑块的操作。

当程序需要读取磁盘上的一个逻辑块时，就会想缓冲区管理程序提出申请，而程序的进程则进入睡眠等待状态。