做过的项目，C语言笔试，Linux系统编程、驱动编程、操作系统。

### 1、Linux内核体系结构

一个完整可用的操作系统主要由四个部分组成：硬件、操作系统内核、操作系统服务和用户应用程序。操作系统内核主要用于对硬件资源的抽象和访问调度。

![操作系统组成](E:\zhf\笔记\Gitee\note\嵌入式\pic\操作系统组成.png)

Linux内核的主要用途是为了与计算机硬件进行交互，实现对硬件部件的编程控制和接口操作，调度对硬件资源的访问，并为计算机上的用户程序提供一个高级的执行环境和对硬件的虚拟接口。

#### 1.1 Linux内核模式

目前Linux内核模式主要可分为**整体的单内核模式**和**层次式的微内核模式**。

在单核模式的系统中，操作系统所提供服务的流程为：应用程序使用指定的参数值执行系统调用指令，使CPU从用户态切换到核心态，然后操作系统根据具体的参数值调用特定的系统调用服务程序，这些服务程序根据需求在调用底层的一些支持函数已完成特定的功能。在完成了应用程序所要求的服务后，操作系统又使CPU从核心态切换回用户态。

Linux内核主要由5个模块构成：**进程调用模块**、**内存管理模块**、**文件系统模块**、进**程间通信模块**和**网络接口模块**。

![内核各模块关系](E:\zhf\笔记\Gitee\note\嵌入式\pic\内核各模块关系.png)

#### 1.2 Linux内核对内存的管理和使用

##### 物理内存

为了能够有效的使用机器中的物理内存，在系统初始化阶段内存被划分为几个功能区域：![物理内存功能分布](E:\zhf\笔记\Gitee\note\嵌入式\pic\物理内存功能分布.png)

在Intel 80386及以后的CPU中提供了两种内存管理（地址变换）系统：**内存分段系统**和**内存分页系统**。其中分页管理系统是可选择的，由系统程序员通过编程来确定是否采用。Linux系统**同时采用了内存分段和分页**。

##### 内存地址空间

在进行地址映射操作时，有三种地址：程序（进程）的虚拟和逻辑地址；CPU的线性地址；实际物理内存地址。

**虚拟地址**：由程序产生的由**段选择符**和**段内偏移地址**两个部分组成的地址。这两部分组成的地址并没有直接用来访问物理内存，而是需要通过分段地址变换机制处理或者映射后才对应到物理内存地址上。选择的索引部分由13个比特位表示，加上GDT和LDT的一个比特位，因此CPU可以索引16384个选择符。每个段的长度取最大值，则最大虚拟地址空间范围是16384*4G=64T；

**逻辑地址**：是指由程序产生的与段相关的偏移地址部分。在Intel保护模式下即是指程序执行代码段限长内的偏移地址。

**线性地址**：是虚拟地址到物理地址变换之间的中间层，是处理器可寻址的内存空间中的地址。

**物理地址**：指出现在CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果地址。如果启用了分页机制，那么线性地址会使用页目录和页表中的项变换成物理地址，如果未启用分页机制，那么线性地址直接成为物理地址。

##### 内存分段机制

CPU地址映射的主要目的是为了解决虚拟内存空间到物理内存空间的映射问题。

虚拟存储管理的实现：

当一个程序需要使用一块不存在的内存时（在内存页表项中已经标出相应内存页面不在内存中），就会触发CPU产生页出错异常中断，并将引起中断的线性地址放到CR2控制寄存器中。因此处理该中断的过程就可以知道发生页异常的确切地址，从而可以把进程要求的页面从二级存储空间（比如硬盘上）加载到物理内存中。如果此时物理内存已经被全部占用，那么可以借助二级存储空间的一部分作为交换缓冲区把内存中暂时不使用的页面交换到二级缓冲区中，然后把要求的页面调入内存中。也即**内存管理的缺页加载机制**。

内存寻址的两种方式：实模式和保护模式

在保护模式下，存在保护描述符项的描述符，有三种类型，每种有不同的目的

- 全局描述符表GDT：该表可被所有程序用于引用访问一个内存段。
- 中断描述符表IDT：保存有定义中断或者异常处理过程的段描述符。
- 局部描述符表LDT：该表用于多任务系统中，通常每个任务使用一个LDT表。

为了让CPU能定位上述三个表项，需要为CPU分别设置GDTR、IDTR和LDTR三个特殊寄存器。这些寄存器中将存储对应表的32位线性基地址和表的限长字节值。表限长值是表的长度值-1.

##### 内存分页管理

如果采取了分页机制，则此时线性地址只是一个中间结果，还需要使用分页机制进行变换，再最终映射到实际的物理内存地址上。分页机制允许我们进行重新定向每次内存应用，以适应我们的特殊要求。

内存分页管理机制的基本原理是将CPU整个线性内存区域划分为4096字节为1页的内存页面。程序申请使用内存时，系统就以内存页为单位进行分配。**分页机制是在分段机制之上实现的** ，为了在保护模式下使用分页机制，需要把控制寄存器的最高比特位（位31）置位。

在使用这种内存分页管理方法时，每个执行中的进程（任务）可以使用比实际内存容量大得多的连续地址空间。为了在使用分页机制的条件下把线性地址映射到容量相对很小的物理内存地址空间上，80386使用了**页目录表**和**页表** ，两者格式基本上相同，都占用4个字节，并且每个页目录表或页表项只能包含1024个页表项。因此一个页目录或一个页表分别工占用一页内存。页表有一个已写位，页目录项没有。

线性地址到物理地址变换：

![线性地址到物理地址](/pic/线性地址到物理地址.png)

在Intel80386系统，其CPU可以提供多达4G的线性地址空间。一个任务的虚拟地址需要首先通过其局部描述符变换为CPU整个线性地址空间中的地址，然后再使用页目录表PDT（一级页表）和页表PT（二级页表）映射到实际物理地址页上。为了使用实际物理内存，每个进程的线性地址通过二级内存页表动态地映射到主内存区域的不同物理内存页上。

##### CPU多任务保护和保护方式

CPU共分为4个保护等级，0级最高，3级最低。Linux内核代码本身会由系统中的所有任务共享。

当一个任务（进程）执行系统调用而陷入内核代码中执行时，就称该进程处于内核态。此时处理器处于特权级最高的内核代码中执行，当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，称其处于用户态。此时处理器在特权级最低的用户代码中运行。

![多任务系统](/pic/多任务系统.png)

##### 虚拟地址、线性地址和物理地址之间的关系

**内核代码和数据的地址**

对于Linux0.11内核代码和数据来说，在head.s程序的初始化操作中已经将内核代码段和数据段都设置长度为16MB的段。在线性地址空间中这两个段的范围重叠，都是从线性地址0开始到地址0XFFFFFF共16MB地址范围，在该范围中含有内核所有的代码、内核段表、页目录表和内核的二级页表、内核局部数据以及内核临时堆栈。