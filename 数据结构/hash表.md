在刷LeetCode题的过程中经常有用到hash表，而距离系统学习数据结构的时间也过去了很久，所以复习一遍，记录笔记；

### hash简介

![img](https://upload-images.jianshu.io/upload_images/1014437-fb0a6c5b564c53bb.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

常说的几个关键字

**key**:输入待查找的值

**value**：我们想要获取的内容

**hash值**：key通过hash函数计算出来的值

**hash函数**（散列函数）：根据key查找值所在的位置。

- 哈希表（散列表）是一种**数据结构**，是一种数组+链表的结构；
- 它提供了快速的插入操作和查找操作，根据键（key）来直接访问内存存储位置的数据结构。它通过计算一个关于键值的函数将所需要查询的数据映射到表中的一个位置来访问记录，
- 无论哈希表总中有多少条数据，**插入和查找的时间复杂度都是为O(1)**，因为哈希表的查找速度非常快，所以在很多程序中都有使用哈希表。
- 同时hash也存在一定的缺点，hash是基于数组，由于数组一旦创建，给数组扩容的成本较高，因此hash表在被填满后性能下降会很严重；
- hash表中很重要的一个概率就是转换【键】或【关键字】，hash表会采用一种转换思想，通过hash函数将【键】或者【关键字】转换为数组下表。

### hash函数

哈希函数的作用是帮我们把非int的**「键」**或者**「关键字」**转化成int，可以用来做数组的下标。

hash的一些特点：

- 第一点：因为数组的下标是从0开始，所以哈希函数生成的哈希值也应该是非负数
- 第二点：同一个key生成的哈希值应该是一样的，因为我们需要通过key查找哈希表中的数据
- 第三点：看起来非常合理，但是两个不一样的值通过哈希函数之后可能才生相同的值，因为我们把巨大的空间转出成较小的数组空间时，不能保证每个数字都映射到数组空白处。所以这里就会才生冲突，在哈希表中我们称之为哈希冲突

构建hash函数需要考虑的因素：

1. 计算hash地址所需要的时间
2. 关键字的长度
3. 表长
4. 关键字分布是否均匀，是否有规律
5. 尽量减少hash冲突

### hash冲突

**对不同的关键字可能得到同一散列地址**

解决冲突

- 开放地址法：若数据不能直接存放在hash函数计算出来的数组下标时，就需要寻找其他位置来存放；
  - 线性探测
    - 在线性探测哈希表中，数据的插入是线性的查找空白单元，例如我们将数88经过哈希函数后得到的数组下标是16，但是在数组下标为16的地方已经存在元素，那么就找17,17还存在元素就找18，一直往下找，直到找到空白地方存放元素。
    - 线性探测哈希表的查找过程有点儿类似插入过程。我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在哈希表中。
    - ​
  - 二次探测
  - 再哈希法
- 链表法